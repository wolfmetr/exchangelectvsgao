09.09.2013
Алгоритм минимизации ПНФ
sum(k_i)(from i = 1 to S) K_i = z1*z2*...*z_n
z_j from {x_r,!x_r,1}
x1x2 xor !x1x2 xor 1
Сложность ПНФ - кол-во слагаемых
Сложность б.ф - сложность наим. ПНФ
Для б.ф n переменных существует 2^(3^n - 2^n) ПНФ
f(x1,...,x_n) = x1(k1'_1 xor k2'_2 xor ... xor k_l') xor !x1(k_(l+1)' xor ... xor k_m') xor (k'_(m+1) xor ... xor k_s')
f(x1,...,x_n) = x1f0(x2,...,xn) xor !x1f1(x2,...,xn) xor f2(x2,...,xn)
x1 = 0 		f^0_x1(x2,...,xn) = f1(x2,...,xn) xor f2(x2,...,xn)
x1 = 1		f^1_x1(x2,...,xn) = f0(x2,...,xn) xor f2(x2,...,xn)

			|f1 = f^0_x1 xor f2
			{						f0,f1 выражаются через f2
			|f0 = f^1_x1 xor f2
Минимизация функции n переменных сводится к перебору всех функций n-1 переменной(2^(2^n-1)) и минимизации на каждом шаге трех функций n-1 переменной.
f = (1011 0100)		f^0_x1 = (1011),	f^1_x1 = (0100)
f2						f1						f0
0000 0,0				1011 1 xor !x2x3,2		0100	!x2,x3,1			3
0001 x2x3,1				1010 !x2,1				0101	x2,1				3
0010 x2!x3,1			1001 !x2!x3 xor x2x3,2	0110	!x2x3 xor x2!x3,2	5
0011 x2,1				1000 !x2!x3,1			0111	1 xor !x2!x3,2		4
0100 !x2x3,1			1111 1,1				0000	0,0					2
0101 x3,1				1110 1 xor x2x3,2		0001	x2x3,1				4
0110 !x2x3 xor x2!x3,2	1101 1 xor x2!x3,2		0010	x2!x3,1				5
0111 x2 xor !x2x3,2		1100 !x2,1				0011	x2,1				4

f(x1,x2,x3) = x1 * 0 xor !x1 * 1 !x2x3
L(f) = 2 - сложность функции
1. Миним. ПНФ для всех ф-ий 1 перем. (0,1,x1,!x1)
2. Минимизация всех функций двух переменных через функции одной переменной.
	...
5. 5 переменных
	2^2^5 ф-ий ~ 4 200 000 000
	Можно минимизировать одну ф-ю 6 переменных (не все)

Алгоритм дает точный минимум
Приближенный минимум - перебор части f2

Один из способов - генетический алгоритм.
Обшая модель генетического алгоритма.
Переборная задача(задача оптимизации)
Целевая функция - T(p1,...,pn)	p1,...,pn - параметры.
Найти минимум T при p1 from M1,..., p_n from M_n(если M_1,...,M_n - конечны то нужно перебрать все наборы p1,...,p_n)
Способы уменьшения мн-ва перебора
1. Покоординатный спуск
	1 шаг - выбираем нач. знач p^0_1,...,p^0_n
	цикл:
		перебор p_i, остальные фиксируем - выбираем значение которое дает минимум
		переходим к i+1
	Остановка по кол-ву шагов или по окончанию спуска.
		
2. Градиентный спуск
	из точки p^0_1,...,p^0_n рассм. сдивги на delta_1,...,delta_n(окрестности точки)
	p^0_1 + delta_1,p^0_2,...,p^0_n
	p^0_1 - delta_1,p^0_2,...,p^0_n		выбираем самый быстрый спуск
		...
	p^0_1 - delta1,p^0_2-delta2,...,p^0_n - delta_n
	
3. Генетический алгоритм
p1,...,pn - кодируем двоичными наборами.
объединяем => двоичное слово - особь/индивид/генетический код.
Функция приспособленности = -T(p1,...,pn)
	Найти максимум приспособленности.
Популяция - набор особей(отсортированные по убыванию приспособленности)
Итерация(шаг) генетического алгоритма:
	Выбираем спец. образом(чем выше приспособленность, тем выше вероятность взятия особи две особи, применяем генетический оператор "кроссовер"(кроссинговер в 
	биологии)
Кроссинговер - случайное перекрещивание двух хромосом.
Код особи 1	a1,a2,...,az ->	a1a2...aib_i+1 ... bz
Код особи 2 b1,b2,...,bz -> b1b2...bia_i+1 ... bz
Получаем 2 новых особи, оцениваем приспособленность.
Выбираем спец. образом одну особь, применяем генетический оператор "мутация"
a1a2...az -> a1a2...a_(i-1) a*_i a_(i+1) ... a_z - новая особь, оцениваем приспособленность.
2 варианта:
1)Собрать новую популяцию, старую убрать.
2)Добавлять новые особи в старую популяцию постепенно.
Окончание по числу шагов или по завершению спуска.

Применение к минимизации булевых функцй:
f2 - особь ГА
приспособленность - сложность полученной формулы.