19.02.2013
ISO
(E_s,D_s) - аутентичное симметричное шифрование.
H:Z_n -> K
->G(): P_k(N,e) S_k(N,d)
->E(P_k,m)
1)Выбор случайного x из Z_n
2)y = x^e(N)
3)k = H(x)	E_s(k,m)
Как не надо использовать RSA
Нельзя шифровать сообщения(textbook)
P_k(N,e) шиф-е с = m^e(N)
S_k(N,d) расш-е m = c^d(n)

1)Медленно
2)Небезопасно(семантическая стойкость)
3)Существует большое количество атак

#
1)Браузер посылает серверу сообощение о начале
2)Сервер посылает публичный ключ браузеру
3)Браузер посылает серверу преобразование RSA от ключа.
4)Ева отслеживает сообщения и выдергивает все необходимые данные
Получает c = k^e(N)
c = (k_1)^e * (k_2)^e (N)
c/(k_1)^e = (k_2)^e(N)

Шаг 1.
Построение таблицы
с/1^e с/2^e ... с/(2^64 - 1)^e. Time: 2^64
Затем из таблицы выбираем соответствующее k_2

Вероятность успеха атаки: 20%

PKCS #1
Версия v 1.5
ОТ
Ключ -(преобр)->|2047 bits| -(RSA)->|ШТ|
128 бит

mode 1 -> создание ЭЦП
mode 2 -> шифрование

Набивка по стандарту 1.5
|02(16bit)|Random Pad|FF(16bit)|msg(key - 128 bit)|

Набивка: 2047-16-16-|m|

Атака на PKCS1 1.5

Sk_s								Pk_s
server|<------c----------------------|browser
	  |		yes: / no:				 |   /|\
	  |----------------------------->|   атакующий
K - симметричный
С - шт, содержащий К

1)Выбор r from Zn	c' = r^e * C(N)
2)Отправка c' на сервер
3)Получение ответа 'yes'/'no'

N = 2^n. Имеется C, получить m
1)(r^e * c)(2^n) = (r*m)^e(2^n) - первый бит
2)(2*t)^e * c(2^N) = (2*t*m)^e(2^n)
3)

PKCS #1 v 2.0 (OAEP)
a)|msg|01|00000...0|	b)|Rand. pad|
Algo:
1. 1) xor H(b)
2. G(a) xor b
3. Конкатенация 1 и 2. <- 2047 bits

H,G - хеш-функции ==> фиксир. размер
Теорема. Если RSA - перестановка с лазейкой и H,G - хеш-функции, тогда RSA - OAEP - стойкая к CCA

Д/з. Зная 1) и 2) получить msg и rand. pad

Вопросы обращения RSA
c = x^e(N)
1)Разложить N на простые(сложно)
2)Выч-ть корень степени e по p,q(просто)

Можно ли выч-ть корень не зная p,q ?

Как не нужно улучшать RSA
