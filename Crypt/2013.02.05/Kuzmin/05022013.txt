05.02.2013
Трудные задачи
x->g^x(p)
DLog_g(g^x) = x
Опр. Будем говорить, что DLog сложна в Zp, если для любого эфф. А: Pr_(g<-Z*_p)x<-Z_q[A(Z*_p,q,g,g^x)=x] - незначима

/*p - простое
g - число из Z*_p
<g> = q
q|(p-1) => 
q = (p-1) в крайнем случае*/

Z*_p, p-большое простое. DLog - сложна
]q - простое, q|(p-1). Выберем g,h from Z*_p
x,y from  Z_y
H(x,y) = g^x*h^y(p)
Показать, что найти коллизию тяжело.

Лемма. Задача нахождения коллизии H сложна, также как и задача DLog(h)
Д-во:существует x0,y0,x,y: H(x_0,y_0) = H(x1,y1)
g^(x0)h^(y0)=g^(x1)h^(x1)
g^(x0-x1) = h^(y1-y0)
g^((x0-x1)/(y1-y0)) = h => DLog_g(h)
n = 1024
Z_2(n) = {N = p*q, где p,q - простые и имеют длину n бит}

В.1 Разложение на мн-ли случ-го N from Z_2(n)
В.2 f(x) степ. >1 случ. N from Z_2(n). Найти x from Z_n: f(x) = 0(N)

Шифрование на открытом ключе
 m A c			 c B
-->E-->			-->D-->m
  /|\			  /|\
  PK_g			  SK_g
1)Обмен ключами. Установление сессии.
2)Работа в неинтерактивных прил-ях.

Одноразовое шифрование			==>		Многоразовое шифрование
каждый ОТ на уникальном ключе				на одном ключе куча ОТ

Клиент								  /-text Alice
PK		to:Alice|text ->	Server --<
							SK		  \-text Eve
		to:Eve|text
		
Опр.
(G,E,D) над (M,C)
									Enemy
------>|Source	  |		PK				
b={0,1}|(PK,SK)<-G|-------------->|		  |
	   |		  |c_i from C	  |		  |
	   |		  |<--------------|		  | Fase 1
	   |		  |-------------->|		  |
	   |		  |m_i = D(SK,C_i)|		  |Check
	   |		  |m0,m1:|m0|=|m1||		  |
	   |		  |<--------------|		  |
	   |		  |
	   |		  |-------------->|		  |
	   |		  |C = E(PK,m_b)  |		  |Fase 2
	   |		  |				  |		  |
	   |		  |Ci from C,Ci=c |		  |
	   |		  |
	   |		  |-------------->|		  |
				   m_i = D(SK,k_i)|		  |
Система шифрования на открытом ключе является стойкой к CCA,если для любого эффективного противника выполняется условие: Adv_cca[A,(G,E,D)] = |Pr[exp(0)=1]-
Pr[exp(1)=1]| - незначимое
#
to:Alice|text->to:Eve\Text
	умеет мд-ть ШТ
	
Функция с лазейкой
Опр. TDF:	X->Y определяемое тройкой эффективных алгоритмов(G,F,F^-1).
	-G - случ. алгоритм(PK,SK)
	-F(PK,*) - детерминированный алг-м преобр-я X->Y
	-F^-1(SK,*) - преобр Y->X обратное F(PK,*)
Для любого(PK,SK)<-G
For all x from X: F^(-1)(SK,F(PK,x)) = x